import chalk from 'chalk';

import { MpcastLogger, Logger, LogLevel } from './mpcast-logger';

const DEFAULT_CONTEXT = 'Podcast Server';

/**
 * @description
 * 默认日志记录，可由 PodcastConfig 配置指定不同的日志级别以及时间戳形式, 当前的默认日志级别是 `LogLevel.INfo`
 *
 * @example
 * ```ts
 * import { DefaultLogger, LogLevel, PodcastConfig } from '@podcast/core';
 *
 * export config: PodcastConfig = {
 *     // ...
 *     logger: new DefaultLogger({ level: LogLevel.Debug, timestamp: false }),
 * }
 * ```
 *
 * @docsCategory Logger
 */
export class DefaultLogger implements MpcastLogger {
  /** @internal */
  level: LogLevel = LogLevel.Info;
  private readonly timestamp: boolean;
  private readonly localeStringOptions = {
    year: '2-digit',
    hour: 'numeric',
    minute: 'numeric',
    day: 'numeric',
    month: 'numeric',
  };
  private static originalLogLevel: LogLevel;

  constructor(options?: { level?: LogLevel; timestamp?: boolean; }) {
    this.level = options && options.level || LogLevel.Info;
    this.timestamp = options && options.timestamp !== undefined ? options.timestamp : true;
  }

  /**
   * @description
   * A work-around to hide the info-level logs generated by Nest when bootstrapping the AppModule.
   * To be run directly before the `NestFactory.create()` call in the `bootstrap()` function.
   *
   * See https://github.com/nestjs/nest/issues/1838
   * @internal
   */
  static hideNestBoostrapLogs(): void {
    const { logger } = Logger;
    if (logger instanceof DefaultLogger) {
      if (logger.level === LogLevel.Info) {
        this.originalLogLevel = LogLevel.Info;
        logger.level = LogLevel.Warn;
      }
    }
  }

  /**
   * @description
   * If the log level was changed by `hideNestBoostrapLogs()`, this method will restore the
   * original log level. To be run directly after the `NestFactory.create()` call in the
   * `bootstrap()` function.
   *
   * See https://github.com/nestjs/nest/issues/1838
   * @internal
   */
  static restoreOriginalLogLevel(): void {
    const { logger } = Logger;
    if (logger instanceof DefaultLogger && DefaultLogger.originalLogLevel !== undefined) {
      logger.level = DefaultLogger.originalLogLevel;
    }
  }

  error(message: string, context?: string, trace?: string | undefined): void {
    if (this.level >= LogLevel.Error) {
      this.logMessage(
        chalk.red(`error`),
        chalk.red(message + (trace ? ` trace: \n${trace}` : '')),
        context,
      );
    }
  }

  warn(message: string, context?: string): void {
    if (this.level >= LogLevel.Warn) {
      this.logMessage(
        chalk.yellow(`warn`),
        chalk.yellow(message),
        context,
      );
    }
  }

  info(message: string, context?: string): void {
    if (this.level >= LogLevel.Info) {
      this.logMessage(
        chalk.blue(`info`),
        message,
        context,
      );
    }
  }

  verbose(message: string, context?: string): void {
    if (this.level >= LogLevel.Verbose) {
      this.logMessage(
        chalk.magenta(`verbose`),
        message,
        context,
      );
    }
  }

  debug(message: string, context?: string): void {
    if (this.level >= LogLevel.Debug) {
      this.logMessage(
        chalk.magenta(`debug`),
        message,
        context,
      );
    }
  }

  private logMessage(prefix: string, message: string, context?: string) {
    process.stdout.write([
      prefix,
      this.logTimestamp(),
      this.logContext(context),
      message,
      '\n',
    ].join(' '));
  }

  private logContext(context?: string) {
    return chalk.cyan(`[${context || DEFAULT_CONTEXT}]`);
  }

  private logTimestamp() {
    if (this.timestamp) {
      const timestamp = new Date(Date.now()).toLocaleString(
        undefined,
        this.localeStringOptions,
      );
      return chalk.gray(timestamp + ' -');
    } else {
      return '';
    }
  }
}
